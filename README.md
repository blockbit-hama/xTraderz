# 주문 매칭 엔진

Rust와 Warp로 구축된 고성능 동시처리 주문 매칭 엔진으로, 금융 시장 주문 처리를 위해 설계되었습니다.

## 현재 기능

### 주문 처리 파이프라인

#### 주문 관리
- **주문 유형**: 지정가 주문 및 시장가 주문 지원
- **주문 작업**: 새 주문 생성, 기존 주문 취소
- **주문 상태 추적**: 신규, 부분 체결, 완전 체결, 취소 상태

#### 가격-시간 우선순위 매칭
- **빠른 주문책 구현**: O(1) 주문 삽입 및 매칭
- **가격-시간 우선순위**: 동일 가격 수준의 주문은 FIFO 순서로 실행
- **효율적인 주문 취소**: 적절한 자료구조를 통한 O(1) 주문 취소

#### 주문책 구조
- **매수/매도 별도 관리**: 매수 및 매도 주문을 위한 별도의 책
- **가격 수준 관리**: 가격 수준별로 그룹화된 주문
- **최적 가격 추적**: 최고 매수/매도 가격에 대한 상수 시간 접근

#### 체결 엔진
- **즉각적인 매칭**: 주문이 반대 방향 주문책과 즉시 매칭
- **부분 체결**: 부분 주문 실행 지원
- **체결 보고서**: 거래 양측에 대한 상세 체결 보고서

#### API & 통신
- **RESTful API**: 주문 제출 및 조회를 위한 HTTP 엔드포인트
- **체결 조회**: 심볼, 주문 ID 및 시간 범위별 체결 필터링
- **WebSocket 실시간 체결 알림**: 체결 발생 시 클라이언트에게 즉시 푸시

### 시장 데이터 파이프라인 (MDP)

#### 시장 데이터 발행자(MDP)
- **오더북 상태 관리**: 매수/매도 호가 상태 관리 및 API 제공
- **체결 데이터 관리**: 최근 체결 내역 저장 및 API 제공
- **시장 통계 계산**: 24시간 가격 변동, 거래량 등 통계 계산
- **캔들스틱 데이터**: 다양한 시간 간격의 OHLCV 데이터 생성 및 관리

#### 시장 데이터 API
- **오더북 API**: 특정 심볼의 현재 오더북 상태 조회
- **체결 내역 API**: 최근 체결 내역 조회
- **시장 통계 API**: 24시간 시장 통계 조회
- **캔들스틱 API**: 다양한 시간 간격의 봉차트 데이터 조회

### 시스템 아키텍처
- **독립적인 파이프라인**: 주문 처리와 시장 데이터 관리의 분리
- **컴포넌트 분리**: 깔끔한 모듈 구조와 책임 분리
- **동시성 모델**: Tokio 기반 비동기 처리

## 계획된 기능

### 고급 주문 유형
- 스탑 주문
- 즉시-또는-취소(IOC) 주문
- 전량-또는-취소(FOK) 주문
- 빙산 주문
- 알고리즘 주문(TWAP/VWAP)

### 가격 제어 및 서킷 브레이커
- 일일 가격 제한
- 서킷 브레이커
- 거래 중단 관리

### 파생상품 지원
- 옵션
- 선물
- 기타 파생상품

### 수수료 구조
- 메이커/테이커 수수료 모델
- 거래량 기반 할인
- 수수료 프로모션

### 위험 관리
- 거래 전 위험 검사
- 거래 한도
- 증거금 계산

### 알림 및 이벤트
- 주문 상태 업데이트
- 가격 알림
- 대량 거래 알림

### 계정 관리
- 포지션 추적
- 손익 계산
- 자금 관리

### 시장 조성 인센티브
- 스프레드 요구사항
- 거래량 요구사항
- 리베이트 구조

### 상품 및 시장 관리
- 다중 시장 지원
- 거래 시간 및 휴일 관리
- 기업 이벤트(배당, 분할)

### 주문책 작업
- 시장 재생 로직
- 주문책 스냅샷
- 스냅샷에서 복구

### 규정 준수 및 규제
- 상세 감사 추적
- 규제 보고
- 시장 감시

## 시작하기

### 사전 요구사항
- Rust 및 Cargo
- Tokio

### 설치
```bash
# 저장소 복제
git clone https://github.com/yourusername/order-matching-engine.git
cd order-matching-engine

# 프로젝트 빌드
cargo build --release

# 애플리케이션 실행
cargo run --release
```

### API 사용법

#### 주문 관리 API

##### 새 주문 생성
```bash
curl -X POST http://127.0.0.1:3030/v1/order \
  -H "Content-Type: application/json" \
  -d '{"symbol":"BTC-KRW","side":"Buy","price":50000000,"order_type":"Limit","quantity":1.5}'
```

##### 주문 취소
```bash
curl -X POST http://127.0.0.1:3030/v1/order/cancel \
  -H "Content-Type: application/json" \
  -d '{"order_id":"f8c3de3d-1fea-4d7c-a8b0-29f63c4c3454"}'
```

##### 체결 조회
```bash
curl -X GET "http://127.0.0.1:3030/v1/execution?symbol=BTC-KRW"
```

#### 시장 데이터 API

##### 오더북 조회
```bash
curl -X GET "http://127.0.0.1:3030/api/v1/orderbook/BTC-KRW"
```

##### 체결 내역 조회
```bash
curl -X GET "http://127.0.0.1:3030/api/v1/executions/BTC-KRW?limit=10"
```

##### 시장 통계 조회
```bash
curl -X GET "http://127.0.0.1:3030/api/v1/statistics/BTC-KRW"
```

##### 캔들스틱 데이터 조회
```bash
curl -X GET "http://127.0.0.1:3030/api/v1/klines/BTC-KRW/1h?limit=24"
```

#### WebSocket 체결 알림

다음과 같이 WebSocket 클라이언트를 사용하여 실시간 체결 정보를 수신할 수 있습니다:

```javascript
const socket = new WebSocket('ws://127.0.0.1:3030/ws/executions');

socket.onmessage = (event) => {
  const execution = JSON.parse(event.data);
  console.log(`체결 발생: ${execution.symbol} - ${execution.side}, 가격: ${execution.price}`);
};
```

## 테스트

다음 명령으로 테스트를 실행하세요:

```bash
cargo test
```

통합 테스트는 제출부터 매칭 및 실행에 이르는 전체 주문 흐름을 보여줍니다.

## 시스템 아키텍처

시스템은 다음과 같이 두 개의 독립적인 파이프라인으로 작동합니다:

1. **주문 처리 파이프라인**: 주문 → 입력시퀀서 → 체결엔진 → 출력시퀀서 → HTTP RESPONSE
2. **시장 데이터 파이프라인**: 체결 정보 → MDP → HTTP API

이러한 독립적인 설계는 다음과 같은 이점을 제공합니다:
- UI 업데이트로 인한 부하가 주문 처리에 영향을 주지 않음
- 필요에 따라 개별 파이프라인 확장 가능
- 한 파이프라인의 장애가 다른 파이프라인에 영향을 주지 않음

## 문서

추가 문서는 `docs` 디렉토리에서 찾을 수 있습니다:
- [아키텍처 문서](docs/architecture.md)
- [API 명세](docs/api.md)
- [시장 데이터 API 문서](docs/market_data_api.md)
- [WebSocket 프로토콜 문서](docs/websocket.md)
